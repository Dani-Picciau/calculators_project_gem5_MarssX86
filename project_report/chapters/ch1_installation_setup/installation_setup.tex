\documentclass[../../main_document/main.tex]{subfiles}
\externaldocument{../../main_document/main}

\begin{document}
\section{Installazione e setup dei simulatori per Windows e macOS}
\subsection{Premessa fondamentale: architetture e compatibilità}
\label{par:paragrafo_1_1}
Prima di procedere, è essenziale capire che questi simulatori non sono normali applicazioni installabili con un semplice clic. Entrambi sono nati in ambito accademico per Linux, ma hanno esigenze molto diverse legate alla loro "età".

\vspace{8pt}
\noindent
Questi due simulatori architetturali (Gem5 e MarssX$86$) nascono e vengono sviluppati nativamente per sistemi Unix-like.
\begin{itemize}[leftmargin=1em]
    \item \textbf{macOS} è un sistema certificato Unix. "Parla la stessa lingua" di Linux, quindi può eseguire molti di questi programmi nativamente (direttamente dal terminale), con il solo aiuto di alcune librerie esterne.
    \item \textbf{Windows} ha un'architettura completamente diversa, per cui non può eseguire nativamente questi programmi. Per poterli eseguire è quindi necessario utilizzare delle soluzioni di \textbf{virtualizzazione o sottosistemi} per creare l'ambiente Unix necessario.
\end{itemize}

\vspace{8pt}
\noindent
Bisogna anche considerare che, anche avendo un sistema Linux (o Unix), c'è il problema delle librerie software necessarie per compilare il codice (il "Time Gap").
\begin{itemize}[leftmargin=1em]
    \item \textbf{Gem5} è un software \textbf{moderno e adattivo}, che viene continuamente sviluppato e aggiornato.\\
    Funziona senza problemi sui sistemi operativi moderni: su macOS lo si compila direttamente mentre su Windows si usa WSL con un'installazione Linux recente (Ubuntu $20.04$/$22.04$).
    \item \textbf{MarssX86} è un progetto "legacy" (molto vecchio, fermo ad $2012$ circa). Richiede compilatori (GCC vecchi) e librerie che sono state rimosse dai sistemi operativi moderni da anni.\\
    Nè macOS moderno ne WSL possono eseguirlo facilmente, dunque è necessario creare una \textbf{Macchina virtuale} (con VirtualBox) che simuli un computer del $2014$ con installato \textbf{Ubuntu $14.04$}.
\end{itemize}

\subsection{Installazione e setup del simulatore Gem5}
Per quanto riguarda l'installazione del simulatore Gem5, la soluzione varia leggermente a seconda del sistema operativo utilizzato.
\subsubsection{Installazione e setup di Gem5 su Windows}
\label{par:ch_1.2.1}
Per installare il simulatore su Windows la soluzione consigliata è \textbf{WSL} (Windows Subsystem for Linux). Questo sottosistema permette di avere un terminale Ubuntu vero e proprio integrato in Windows. Dunque, l'installazione si compone di diversi passaggi:
\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: attivazione di WSL}
    \begin{enumerate}[leftmargin=1.3em]
        \item Aprire la \textbf{PowerShell} come amministratore;
        \item Digitare \cmd{\texttt{wsl ---install}}, premere invio e attendere il compleatmento del download;
        \item Al termine, seguire le istruzioni a schermo per creare \textit{username} e \textit{password} Ubuntu.
    \end{enumerate}
    
    \vspace{8pt}
    \noindent
    Una volta fatto ciò, la situazione iniziale nel terminale dovrebbe essere quella mostrata in figura \ref{fig:ch1_fig1}, ed eseguendo il comando \texttt{pwd} sarà possibile vedere il proprio posizionamento all'interno del sottosistema WSL.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.75\textwidth]{chapter1_figures/img1.png}
        \vspace{-5pt}
        \caption{Schermata iniziale del sottosistema WSL}
        \label{fig:ch1_fig1}
    \end{figure}

    \item \textbf{\textit{Passo 2}: installazione delle dipendenze}\\
    Nel terminale di Ubuntu appena aperto incollare questi comandi uno alla volta:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Aggiorna i pacchetti
sudo apt update && sudo apt upgrade -y
    \end{lstlisting}
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Installa compilatori, Python e librerie necessarie a Gem5
sudo apt install build-essential git m4 scons zlib1g zlib1g-dev libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev python3-dev python-is-python3 libboost-all-dev pkg-config libpng-dev libhdf5-dev libcapstone-dev -y
    \end{lstlisting}
    \textbf{\textit{Note}}: facendo copia-incolla dei comandi potrebbero verificarsi dei problemi dovuti ai \textit{"-"} letti dal terminale di Ubuntu come caratteri speciali, in tal caso è consigliato riscriverli a mano.

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: scaricare e compilare Gem5}\\
    Prima di \textbf{scaricare} Gem5 è consigliato creare una cartella adatta a poterlo contenere.\\
    Quest'operazione viene svolta principalmente perché in futuro dovremo scaricare anche il simulatore architetturale \textbf{MarssX86}: così facendo avremo entrambi i simulatori in una cartella apposita.\\
    Senza spostarsi dalla posizione iniziale \texttt{/home/NomeUtente} si va a creare la cartella:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
mkdir dev_local // Crea la cartella dev_local
cd dev_local // Ci si sposta dentro dev_local per scaricare gem5
    \end{lstlisting}
    Una volta posizionati in \texttt{/home/utente/dev\_local} è possibile utilizzare il comando \texttt{git clone} per scaricare il simulatore gem5 dal repository ufficiale 
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Clonare il repository del progetto nel proprio workspace
git clone (*@\url{https://github.com/gem5/gem5.git}@*) 
    \end{lstlisting}
    Quando la clonazione sarà completata, all'interno di \texttt{dev\_local} sarà presente un'altra cartella nominata "gem5" al cui interno saranno presenti tutti i file necessari per la compilazione del simulatore.

    \vspace{8pt}
    \noindent
    Prima di far partire la compilazione è necessario fare alcune \textbf{premesse importanti}.\\
    Utilizzare un calcolatore con $16$GB o meno di memoria RAM non basterà: Gem5 è enorme e usa template C++ complessi, ogni core che compila può occupare anche 2-3 GB di RAM.
    Inoltre, considerando che Windows utilizza parte di questa RAM, la situazione si complica ulteriormente.\\
    Una possibile soluzione a questo problema, nel caso in cui non si disponesse di un calcolatore con la quantità di RAM necessaria, è quella di "truccare" WSL per dargli più memoria usando il disco fisso come se fosse RAM (operazione di Swap della memoria):
    \begin{enumerate}[leftmargin=1.3em]
        \item Aprire il blocco note di windows;
        \item Incollare esattamente queste righe:
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
[wsl2]
memory=10GB
swap=16GB
        \end{lstlisting}
        In questo modo stiamo dando a WSL massimo $10$GB di RAM vera, ma aggiungiamo $16$GB di "memoria lenta" su disco per evitare che la compilazione vada in crash.
        \item Salvare il file con nome \texttt{.wslconfig} (assicurandosi che non ci sia .txt alla fine!) nella propria cartella utente principale: \texttt{C:\textbackslash Utenti\textbackslash NomeUtente\textbackslash .wslconfig}
        \item Aprire la PowerShell (sempre in modalità amministratore) e spegnere WSL per applicare la modifica con il comando \cmd{\texttt{wsl ---shutdown}}
    \end{enumerate}

    \vspace{8pt}
    \noindent
    Una volta fatte queste modifiche, è finalmente possibile {far partire la compilazione}: riaprendo il terminale Ubuntu e posizionandosi in \texttt{/home/NomeUtente/dev\_local/gem5} deve essere scritto il seguente comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
scons build/ARM/gem5.opt -j 1
    \end{lstlisting}
    Tramite di esso la compilazione viene fatta partire utilizzando un solo core della cpu. Nonostante l'utilizzo dello "Swap" con la memoria del disco, la compilazione può essere talmente pesante che utilizzando più di un core per la compilazione si rischierebbe di saturare la RAM mandando in crash la compilazione.
    È \textbf{assolutamente "normale"} che i tempi di compilazione varino da 1h a 2h in base alla cpu che si ha a disposizione.

    \vspace{8pt}
    \noindent
    \textbf{\textit{Note}}: non appena la compilazione del simulatore ARM termina, per incominciare la compilazione del simulatore RISC-V basterà reinviare il comando \texttt{scons} quì sopra, sostituendo \texttt{ARM} con \texttt{RISCV}.

    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 4}: test di funzionamento}\\
    Per testare che il simulatore sia stato installato correttamente è possibile lanciare un comando di prova già incluso al suo interno.\\
    Sempre posizionati in \texttt{/home/NomeUtente/dev\_local/gem5}, lanciare questo comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
./build/ARM/gem5.opt configs/deprecated/example/se.py --cmd=tests/test-progs/hello/bin/arm/linux/hello    
    \end{lstlisting}
    \begin{figure}[H]
        \centering
        \vspace{-10pt}
        \includegraphics[width=\textwidth]{chapter1_figures/img2.png}
        \vspace{-20pt}
        \caption{test di simulazione per Gem5}
        \label{fig:ch1_fig2}
    \end{figure}
    L'esecuzione di questo comando comporterà la creazione, all'interno della cartella "m5out" situata all'interno della cartella "gem5", di \textbf{due file fondamentali}:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{"stats.txt"}}: Contiene tutte le statistiche (cicli, cache miss, istruzioni eseguite, ecc.). È il file di testo enorme che si dovrà analizzare dopo l'esecuzione vera e propria del workload;
        \item \textbf{\textit{"config.ini"}}: Contiene la descrizione dettagliata dell'hardware appena simulato (utile per verificare se è stata davvero usata la CPU che si voleva).
    \end{itemize}
\end{itemize}

\subsubsection{Installazione e setup di Gem5 su macOS}
\label{par:ch_1.2.2}
Sebbene sia teoricamente possibile compilare nativamente su macOS, la gestione delle dipendenze (in particolare Python e Protobuf) risulta spesso instabile a causa degli aggiornamenti di sistema Apple.

\vspace{8pt}
\noindent
Per garantire la \textbf{massima riproducibilità} e stabilità, la soluzione raccomandata per macOS è l'utilizzo di un container \textbf{Docker} basato su Ubuntu $22.04$. Come per WSL, questo approccio permette di avere un ambiente di sviluppo basato su Linux nativo.

\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: preparazione del container}
    \begin{enumerate}[leftmargin=1.3em]
        \item Scaricare e installare Docker desktop dal sito ufficiale \url{https://www.docker.com/};
        \item È consigliato aprire il terminale posizionandosi nella cartella del proprio apple account come mostrato in figura \ref{fig:ch1_fig3}; 
        \begin{figure}[H]
            \centering
            \vspace{-10pt}
            \includegraphics[width=0.8\textwidth]{chapter1_figures/img3.png}
            \vspace{-5pt}
            \caption{posizionamento iniziale per l'installazione di docker}
            \label{fig:ch1_fig3}
        \end{figure}
        \vspace{-12pt}
        \item Creare il proprio workspace che conterrà il simulatore Gem5 e in futuro MarssX86.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
mkdir dev_local
cd dev_local
        \end{lstlisting}
    \end{enumerate}

    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 2}: installazione delle dipendenze}
    \begin{enumerate}[leftmargin=1.3em]
        \item All'interno di \texttt{/Users/NomeUtente/dev\_local}, installare tutte le dipendenze necessarie per la creazione del container di Ubuntu $22.04$:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker pull ghcr.io/gem5/ubuntu-24.04_all-dependencies:v25-1
        \end{lstlisting}
        \item Una volta che il workspace è stato creato è possibile far partire il container di Ubuntu (sempre stando posizionati in \texttt{/Users/NomeUtente/dev\_local}):
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker run --volume /Users/NomeUtente/dev_local/gem5:/gem5 --rm -it ghcr.io/gem5/ubuntu-24.04_all-dependencies:v24-0        
        \end{lstlisting}
        Il completamento di questo comando dovrebbe aprire una riga di comando di questo tipo, ad indicare che siamo all'interno del container Ubuntu.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:/#    
        \end{lstlisting}
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: scaricare e compilare Gem5}\\
    All'interno del container Ubuntu appena creato, è possibile \textbf{scaricare} il repository ufficiale tramite il comando \texttt{git clone}:
    \begin{lstlisting}[style=mystyle, language=C++, escapeinside={(*@}{@*)}]
root@{...}:/#  git clone (*@\url{https://github.com/gem5/gem5.git}@*) 
    \end{lstlisting}
    Verrà creata una cartella "gem5" al cui interno saranno al cui interno saranno presenti tutti i file necessari per la compilazione del simulatore.

    \vspace{8pt}
    Come specificato al \textbf{\textit{"Passo 3"}} del capitolo \ref{par:ch_1.2.1} la compilazione richiede una grande quantità di RAM per cui è richiesto un calcolatore con $16$ o più GB di memoria RAM (solo per la compilazione di Gem5!). Dopo alcuni test da noi effettuati è risultato che la compilazione su un calcolatore con $8$GB di RAM potrebbe impiegare anche mezza giornata!\\
    Proprio per questo motivo, anche disponendo di $16$GB di memoria RAM è necessario andare nella GUI di Docker \texttt{impostazioni} $\rightarrow$ \texttt{resources} $\rightarrow$ \texttt{advanced}, e da quì cambiare le seguenti impostazioni:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{Memory limit}}: impostiamo la capacità massima di memoria RAM che Docker può utilizzare. È consigliato impostarlo quasi al massimo, (ad esempio, con $16$ GB di RAM a disposizione impostarlo a $14/15$) per permettere al sistema operativo (macOS) di "sopravvivere"
        \item \textbf{\textit{Swap}}: Invece, tramite questa impostazione, indichiamo quanto spazio di "memoria lenta" prendere dal disco nel caso in cui la RAM vada in saturazione a causa della pesantezza di compilazione.
    \end{itemize}

    \vspace{8pt}
    Una volta che il repository è stato clonato ci si sposta all'interno della cartella "gem5" per far partire la \textbf{compilazione del simulatore}, utilizzando $1$ o al massimo $2$ core per evitare che la compilazione vada in crash a causa della saturazione della RAM a dispozione.
    \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
// Mi sposto all'interno della cartella gem5
root@{...}:/# cd gem5 

// Compilazione ARM
root@{...}:/gem5# scons build/ARM/gem5.opt -j1 
    \end{lstlisting}
    Come per Windows, anche la compilazione su macOS può impiegare da $1$h a $2$h, ed è \textbf{"normale"} vista la mole di file da scaricare.\\
    \textbf{\textit{Note}}: non appena la compilazione del simulatore ARM termina, per incominciare la compilazione del simulatore RISC-V basterà reinviare il comando \texttt{scons} quì sopra, sostituendo \texttt{ARM} con \texttt{RISCV}.

    \vspace{8pt}
    \textbf{\textit{Passo 4}: test di funzionamento}\\
    Per testare che il simulatore sia stato installato correttamente è possibile lanciare un comando di prova già incluso al suo interno.\\
    Sempre posizionati in \texttt{root@1ab1ef08f2f:/gem5\#}, lanciare questo comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
./build/ARM/gem5.opt configs/deprecated/example/se.py --cmd=tests/test-progs/hello/bin/arm/linux/hello    
    \end{lstlisting}
    L'esecuzione di questo comando comporterà la creazione, all'interno della cartella "m5out" situata all'interno della cartella "gem5", di \textbf{due file fondamentali}:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{"stats.txt"}}: Contiene tutte le statistiche (cicli, cache miss, istruzioni eseguite, ecc.). È il file di testo enorme che si dovrà analizzare dopo l'esecuzione vera e propria del workload;
        \item \textbf{\textit{"config.ini"}}: Contiene la descrizione dettagliata dell'hardware appena simulato (utile per verificare se è stata davvero usata la CPU che si voleva).
    \end{itemize}
\end{itemize}


\subsection{Installazione e setup del simulatore MarssX86}
Nonostante sia un processo abbastanza lungo e tedioso la scelta consigliata per effettuare l'installazione del simulatore, sia per Windows che per macOS, è utilizzare Docker.
\subsubsection{Installazione e setup di MarssX86 su Windows}
\label{par:ch_1.3.1}
L'utilizzo di Docker è la scelta raccomandata per mantenere un flusso di lavoro unificato. Grazie all'integrazione con WSL 2, è possibile avviare l'ambiente "legacy" necessario per MarssX86 direttamente dallo stesso terminale utilizzato per Gem5 (come visto al passo $1$ del capitolo \ref{par:ch_1.2.1}), senza dover configurare macchine virtuali esterne pesanti.
\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: Configurazione (WSL + Docker)}
    \begin{enumerate}[leftmargin=1.3em]
        \item Scaricare e installare Docker desktop dal sito ufficiale \url{https://www.docker.com/};
        \item Aprire docker desktop su Windows;
        \item Andare nelle impostazioni (icona dell'ingranaggio in alto a destra);
        \item Spostarsi nella sezione \textbf{resources} e poi in \textbf{WSL integration};
        \item Assicurarsi di attivare la casella "Ubuntu" per abilitare l'integrazione;
        \item Cliccare su \textit{"apply e restart"}
    \end{enumerate}
    A questo punto, aprendo il terminale WSL, è possibile verificarne il funzionamento tramite il comando \cmd{\texttt{docker --version}}.
    
    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 2}: preparazione del container}
    \begin{enumerate}[leftmargin=1.3em]
        \item Nel terminale WSL spostarsi all'interno della cartella \texttt{/home/NomeUtente/dev\_local} (come fatto al passo $3$ del capitolo \ref{par:ch_1.2.1}), e creare una cartella per il progetto Marss con al suo interno il file di definizione dell'ambiente:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
mkdir marss
cd marss
nano Dockerfile
        \end{lstlisting}
        All'interno dell'editor che si aprirà dopo l'ultimo comando (\texttt{nano Dockerfile}), incollare il seguente contenuto che definisce un ambiente Ubuntu 18.04 con tutte le dipendenze necessarie.\\
        Nonostante MarssX86 sia stato scritto in un ambiente Ubuntu $14.04$ (risalente al 2012), non è possibile replicare tale ambiente, poiché da molti anni i server hanno cancellato tutti i file. Dunque una possibile strategia è quella di usare un sistema operativo più recente (Ubuntu 18.04) i cui server funzionano perfettamente, ma installare manualmente i "vecchi" compilatori.
        \begin{lstlisting}[style=mystyle, language=bash, escapeinside={(*@}{@*)}]
# Usiamo Ubuntu 18.04 che ha server ancora attivi e stabili
FROM ubuntu:18.04

# Aggiorniamo i repository (funzionera' senza errori 404)
RUN apt-get update

# Installiamo i tool di base e specificamente GCC 4.8 / G++ 4.8
# MarssX86 richiede queste versioni antiche per compilare
RUN apt-get install -y build-essential git scons zlib1g-dev python2.7 python-minimal g++ \
    vim libsdl1.2-dev gcc-4.8 g++-4.8

# Configuriamo il sistema per usare GCC 4.8 come default assoluto
# Questo "inganna" Marss facendogli credere di essere su un vecchio sistema
RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100 && \
    update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 100

# Cartella di lavoro
WORKDIR /root/marss

CMD ["/bin/bash"]
        \end{lstlisting}
        \item Rimanendo posizionati in \texttt{/home/NomeUtente/dev\_local/marss}, lanciare il comando di build per l'ambiente Ubuntu.  Verrà richiesta una password, inserire quella dell'account Ubuntu come fatto al \textbf{\textit{"Passo 1"}} del capitolo \ref{par:ch_1.2.1}.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
sudo docker build --no-cache -t marss_env .
        \end{lstlisting}
        \item Infine, è possibile creare l'ambiente Ubuntu scelto. Servirà la password.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
sudo docker run -it --name marss_container -v "$PWD":/root/marss marss_env
        \end{lstlisting}
        \textbf{\textit{Nota importante}}: l'aggiunda del comando \cmd{\texttt{-v "\$PWD":/root/marss}} crea un collegamento diretto tra la cartella in cui ci si trova (\texttt{/home/NomeUtente/dev\_local/marss}) nel disco e la cartella di lavoro "virtuale" del container. Senza di esso non si vedrebbero le modifiche effettuate nel container, costringendo a copiare ogni file che si vuole utilizzare nel disco del computer, tramite comandi aggiuntivi.
        Ovviamente, il container rimane necessario per compilare/eseguire i file dell'ambiente Ubuntu scelto.

        \vspace{8pt}
        Una volta fatto ciò, si dovrebbe essere riusciti ad entrare nell'ambiente di simulazione, e a schermo dovrebbe vedersi questo:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:~/marss#
        \end{lstlisting}   
        \begin{figure}[H]
            \centering
            \vspace{-10pt}
            \includegraphics[width=0.75\textwidth]{chapter1_figures/img4.png}
            \vspace{-5pt}
            \caption{ambiente di simulazione del MarssX86}
            \label{fig:ch1_fig4}
        \end{figure}

        \vspace{-15pt}
        Inserendo subito il comando \texttt{"pwd"} si potra vedere come ci si trova in \texttt{/root/marss} come specificato nel Dockerfile.  
        \item Per \textbf{tornare alla bash di Ubuntu} basterà scrivere il comando \texttt{"exit"} da qualsiasi posizione, mentre per rientrare nell'ambiente già creato servirà un comando differente da lanciare (posizionati in \texttt{/home/NomeUtente/dev\_local/marss}):
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker start -ai marss_container
        \end{lstlisting}  

        \vspace{8pt}
        Invece, per rimuovere il container serve prima sapere il container id. Nell'ambiente Ubuntu (quindi dopo avere fatto \texttt{"exit"}) utilizzare il seguente comando:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker ps
        \end{lstlisting}     
        Subito dopo
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker rm <container id>
        \end{lstlisting}    
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: scaricare e compilare MarssX86}\\
    Dopo essere riusciti ad entrare dentro l'ambiente di simulazione, bisogna \textbf{scaricare il repository} del progetto ufficiale (posizionati in \texttt{/root/marss}):
    \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:~/marss# git clone (*@\url{https://github.com/avadhpatel/marss.git}@*)
    \end{lstlisting}
    Una volta completata la clonazione, all'interno di \texttt{/root/marss} verrà scaricata un ulteriore cartella "marss" contenente i file reltivi al repository.\\
    Anche in questo caso la compilazione risulta abbastanza pesante a causa della quantità di RAM richiesta. Fortunatamente, Docker desktop su Windows eredita da WSL il file \texttt{.wslconfig} (\textbf{\textit{passo 3}} del capitolo \ref{par:ch_1.2.1}) creato per fare in modo che la compilazione non vada in crash.

    \vspace{8pt}
    Prima di \textbf{procedere con la compilazione} ci sono alcune problematiche che vanno risolte, relative alle discrepanze tra l'utilizzo di comandi moderni e compilatori vecchi oppure causate da librerie di sicurezza moderne (già presenti nella versione $18.04$ di Ubuntu che stiamo utilizzando) che bloccano la compilazione del file finale di compilazione. Queste problematiche sono sorte in fase di compilazione stessa, e avendole individuate, è necessario risolverle per garantire il funzionamento della compilazione.
    \begin{enumerate}[leftmargin=1.3em]
        \item Posizionarsi in \texttt{/root/marss/marss/ptlsim} e aprire il file \textit{"SConstruct"} che rappresenta il "cuore" del simulatore PTLsim:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:~/marss/marss/ptlsim# apt-get install -y nano
root@{...}:~/marss/marss/ptlsim# nano SConstruct
        \end{lstlisting}
        \item Una volta all'interno dell'editor di testo nano per il file \textit{"SConstruct"} cercare la riga:
        \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
env.Append(CCFLAGS = ['-fdiagnostics-color=always'])
        \end{lstlisting}
        ed eliminarla o commentarla utilizzando un "\#". Per aiutarsi è possibile entrare in modalità ricerca con la combinazione di comandi \texttt{ctrl + w}. 

        \vspace{8pt}
        Subito sotto questa riga, ne dovrebbe essere presente un'altra di questo tipo:
        \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
env.Append(CCFLAGS = ' -std=gnu++11 ')
        \end{lstlisting}
        la quale deve essere modificata in questo modo:
        \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
env.Append(CCFLAGS = ' -std=gnu++11 -U_FORTIFY_SOURCE ')
        \end{lstlisting}  
        In questo modo stiamo dicendo al compilatore di \textit{"disabilitare i controlli di sicurezza moderni per il codice vecchio del repository"}.\\
        Premere \texttt{ctrl+o} per salvare le modifiche, invio, e \texttt{ctrl+x} per uscire dall'editor di testo.

        \item Tornati nell'ambiente di simulazione bisogna effettuare lo stesso procedimento nel file \textit{"SConstruct"} principale, quindi non quello presente in \texttt{/root/marss/marss/ptlsim} ma in \texttt{/root/marss/marss/}, quindi:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:~/marss/marss# nano SConstruct
        \end{lstlisting}     
        Una volta all'interno dell'editor di testo, bisogna scendere nel file fino a trovare una instruzione condizionale di questo tipo:
        \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
if int(pretty_printing) :
    base_env = Environment(
            CXXCOMSTR = compile_source_message,
            CREATECOMSTR = create_header_message,
            CCCOMSTR = compile_source_message,
            SHCCCOMSTR = compile_shared_source_message,
            SHCXXCOMSTR = compile_shared_source_message,
            ARCOMSTR = link_library_message,
            RANLIBCOMSTR = ranlib_library_message,
            SHLINKCOMSTR = link_shared_library_message,
            LINKCOMSTR = link_program_message,
            )
else:
    base_env = Environment()
        \end{lstlisting}    
        Questo blocco serve a creare l'ambiente di compilazione (base\_env). Bisogna intercettare quella variabile appena è stata creata e aggiungere il \textit{"flag salvavita"} che disabilita i controlli di sicurezza troppo moderni. Dopo l'else bisogna aggiungere le seguenti righe:
        \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
...
...

else:
    base_env = Environment()

base_env.Append(CFLAGS = ['-U_FORTIFY_SOURCE'])
base_env.Append(CCFLAGS = ['-U_FORTIFY_SOURCE'])
        \end{lstlisting}    
        Fatto ciò, nuovamente \texttt{ctrl+o} per salvare le modifiche, invio, e poi \texttt{ctrl+x} per tornare nell'ambiente di simulazione.
    \end{enumerate}

    \vspace{8pt}
    Effettuate queste modifiche è finalmente possibile \textbf{compilare} tramite il comando:
    \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
root@{...}:~/marss/marss# scons -Q C=1 debug=0
    \end{lstlisting} 
    Come risultato finale si dovrebbe visualizzare un comando di questo tipo:
    \begin{figure}[H]
        \centering
        \vspace{-5pt}
        \includegraphics[width=0.65\textwidth]{chapter1_figures/img5.png}
        \vspace{-5pt}
        \label{fig:ch1_fig5} 
    \end{figure}
    Al termine della compilazione è possibile verificare la presenza dell'eseguibile tramite il seguente comando:
    \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss# ./qemu/qemu-system-x86_64 --version
    \end{lstlisting}
Se in risposta si riceve un qualcosa del tipo:
    \begin{lstlisting}[style=mystyle]
QEMU emulator version 0.14.1, Copyright (c) 2003-2008 Fabrice Bellard
    \end{lstlisting}
    allora il simulatore è pronto all'uso.

    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 4}: installazione immagine disco rigido}\\
    Dopo aver completato la fase di installazione del simulatore con l'ambiente Ubuntu, si passa alla fase di installazione del sistema operativo vero e proprio.\\
    A differenza di Gem5 che carica direttamente l'eseguibile, MarssX86 è un simulatore Full System (FS): simula un PC intero (BIOS, scheda madre, disco rigido). Quindi, per farlo funzionare, ci serve un'immagine del disco rigido con dentro un Sistema Operativo (Ubuntu vecchio).
    \begin{enumerate}[leftmargin=1.3em]
        \item Si rende necessario quindi, preparare la cartella dei dischi. Posizionati in \texttt{root/marss/} per creare una cartella \textit{"disks"}:
        \begin{lstlisting}[style=mystyle]
mkdir disks
cd disks
        \end{lstlisting}  
        \item  Una volta creata la cartella, spostarsi in \texttt{root/marss/marss/disks} e installare il comando \textit{"wget"} per poter poi installare il sistema operativo da emulare tramite l'ambiente Ubuntu preparato precentemente.
        \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss/disks# apt-get install -y wget bzip2
        \end{lstlisting} 
        Installerà tutte le librerie necessarie al suo funzionamento, ci sarà da aspettare qualche secondo.
        \item  A questo punto è tutto pronto per installare il sistema operativo.\\
        Il sistema operativo scelto è ottenibile al seguente link \url{https://people.debian.org/~aurel32/qemu/amd64/debian_squeeze_amd64_standard.qcow2}.\\
        Si tratta di \textit{Debian Squeeze}, una distribuzione di Linux rilasciata nel febbraio del 2011.\\
        La scelta di questa distribuzione specifica è dettata da vincoli di compatibilità: 
        \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
            \item \textbf{Sincronizzazione Temporale}: MarssX86 è stato sviluppato intorno al 2011-2012, basandosi su una versione di QEMU (0.14) di quel periodo. I simulatori Full System simulano l'hardware di quell'epoca, e Debian Squeeze, essendo del 2011, "parla la stessa lingua" del simulatore.
            \item \textbf{Leggerezza (no graphic)}: l'immagine scaricata è una versione "Standard/Server", priva di interfaccia grafica (niente finestre, niente mouse), e questo è cruciale poiché riduce il consumo di RAM e CPU simulata
        \end{itemize}
        Dunque, per installare la distribuzione scelta si utilizza il seguente comando:
        \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss/disks# wget https://people.debian.org/~aurel32/qemu/amd64/debian_squeeze_amd64_standard.qcow2
        \end{lstlisting} 
        \item Nonostante l'immagine del disco sia idonea per MarssX86, è necessaria una versione precedente. L'immagine scaricata è in formato QCOW2 versione 3 (introdotto da QEMU 1.1 nel 2012), ma MarssX86 usa QEMU 0.14 (2011), che conosce solo la versione 2.\\
        Per risolvere questo problema legato alla versione, è necessario  effettuare un "downgrade" dell'header del file del disco virtuale per renderlo leggibile dal vecchio simulatore:
        \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss/disks# apt-get update && apt-get install -y qemu-utils
        \end{lstlisting}   
        \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss/disks# qemu-img convert -f qcow2 -O qcow2 -o compat=0.10 debian_squeeze_amd64_standard.qcow2 debian_old.qcow2
        \end{lstlisting}   
        \cmd{\texttt{compat=0.10}} forza il formato a essere leggibile dai simulatori del 2011, creando una nuova immagine del disco \textit{debian\_old.qcow2}.
        \item Ora, per far partire a distribuzione Debian, basterà lanciare il seguente comando, posizionati in \texttt{/root/marss/marss}:
        \begin{lstlisting}[style=mystyle]
root@{...}:~/marss/marss# ./qemu/qemu-system-x86_64 -m 1G -hda /root/marss/disks/debian_old.qcow2 -nographic
        \end{lstlisting} 
        Verrà richiesto login e password, le credenziali saranno \textit{"root"} per entrambi i campi.
        \begin{figure}[H]
            \centering
            \vspace{-5pt}
            \includegraphics[width=0.7\textwidth]{chapter1_figures/img7.png}
            \vspace{-5pt}
            \label{fig:ch1_fig7} 
        \end{figure}
    \end{enumerate} 
\end{itemize} 
\noindent
\textbf{\textit{Ruolo nell'architettura della simulazione}}\\
La procedura si presenza abbastanza complessa, dunque, per chiarire il funzionamento complessivo, facciamo un recap:
\begin{enumerate}[leftmargin=1.3em]
\item \textbf{Host Fisico}: il PC Windows (server WSL) o il PC macOS.
\item \textbf{Container Docker}: l'ambiente che contiene le librerie necessarie per compilare ed eseguire il simulatore.
\item \textbf{Simulatore (MarssX86/QEMU)}: il programma che finge di essere un computer fisico (crea CPU, RAM e Disco finti).
\item \textbf{Guest OS (Debian Squeeze)}: Il sistema operativo che "vive" dentro il disco finto e che esegue effettivamente il codice C.
\end{enumerate}




\subsubsection{Installazione e setup di MarssX86 su macOS}
Dal momento che, per simulare MarssX86 su Windows si sta utilizzando Docker, gran parte dei passaggi da effettuare su macOS rimangono identici.

\vspace{8pt}
\noindent
Tuttavia, per impostazione predefinita, Docker su un dispositivo che monta un processore apple silicon crea un contenitore ARM64 (aarch64). MarssX86 è un simulatore più vecchio progettato esclusivamente per architetture x86\_64 (Intel/AMD), dunque ne consegue che se si andasse ad effettuare il seguente script di build (SConstruct):
\begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
root@{...}:~/marss/marss# scons -Q C=1 debug=0
\end{lstlisting} 
verrebbe rilevato che la CPU è basata su ARM e il processo verrebbe interrotto non sapendo come effettuare la compilazione.

\vspace{8pt}
\noindent
A questo punto, facendo riferimento al capitolo \ref{par:ch_1.3.1} è necessario eliminare il \textbf{\textit{"passo 1"}} poiché WSL non viene utilizzato, revisionare il \textbf{\textit{"passo 2"}}, modificando semplicemente i comandi di build e creazione dell'ambiente Ubuntu, e mantenere il \textbf{\textit{"passo 3"}} invariato.
\begin{enumerate}[leftmargin=1.3em]
    \item Come spiegato al \textbf{\textit{"passo 1"}} del capitolo \ref{par:ch_1.2.2} scaricare Docker dal link fornito. 
    Inoltre, è consigliato creare una cartella \textit{"marss"} all'interno di \textit{"dev\_local"}, per mantenere separati i flussi di lavoro tra i due simulatori.\\
    Per fare ciò è necessario essere posizionati in \texttt{/Users/NomeUtente/dev\_local/marss}
    \begin{figure}[H]
        \centering
        \vspace{-10pt}
        \includegraphics[width=0.9\textwidth]{chapter1_figures/img6.png}
        \vspace{-10pt}
        \label{fig:ch1_fig6}  
    \end{figure}
    \item All'interno della cartella \textit{"marss"}, come fatto per Windows, bisogna creare il "Dockerfile" all'interno del quale definire l'ambiente Ubuntu $18.04$, dunque:
    \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
nano Dockerfile
    \end{lstlisting} 
    e in seguito inserire le seguenti righe di codice:
    \begin{lstlisting}[style=mystyle, language=bash, escapeinside={(*@}{@*)}]
# Usiamo Ubuntu 18.04 che ha server ancora attivi e stabili
FROM ubuntu:18.04

# Aggiorniamo i repository (funzionera' senza errori 404)
RUN apt-get update

# Installiamo i tool di base e specificamente GCC 4.8 / G++ 4.8
# MarssX86 richiede queste versioni antiche per compilare
RUN apt-get install -y build-essential git scons zlib1g-dev python2.7 python-minimal g++ \
    vim libsdl1.2-dev gcc-4.8 g++-4.8

# Configuriamo il sistema per usare GCC 4.8 come default assoluto
# Questo "inganna" Marss facendogli credere di essere su un vecchio sistema
RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100 && \
    update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 100

# Cartella di lavoro
WORKDIR /root/marss

CMD ["/bin/bash"]
    \end{lstlisting}
    \item Rimanendo sempre posizionati in \texttt{/Users/NomeUtente/dev\_local/marss} lanciare il comando di build per l'ambiente Ubuntu.
    \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
docker build --platform linux/amd64 --no-cache -t marss_env .
    \end{lstlisting} 
    Questo dice a Docker di fingere che sia una macchina Intel durante la costruzione.\\
    \textbf{\textit{Note}}: questo passaggio richiederà più tempo rispetto a prima a causa dell'emulazione.
    \item Subito dopo creare e far partire il container, specificando la piattaforma:
    \begin{lstlisting}[style=mystyle, escapeinside={(*@}{@*)}]
docker run --platform linux/amd64 -it --name marss_container -v "$PWD":/root/marss marss_env
    \end{lstlisting} 
    Una volta lanciato questo comando si dovrebbe essere riusciti ad entrare nel container e a terminale si dovrebbe visualizzare questo:
    \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@{...}:~/marss#
    \end{lstlisting}
    \item Dopo essere riusciti ad entrare all'interno del container, i seguenti passaggi sono tali e quali a quelli descritti dal \textbf{\textit{"passo 3"}} in poi del capitolo \ref{par:ch_1.3.1}.
\end{enumerate}
\end{document}