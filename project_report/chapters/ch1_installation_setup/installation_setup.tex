\documentclass[../../main_document/main.tex]{subfiles}
\externaldocument{../../main_document/main}

\begin{document}
\section{Installazione e setup dei simulatori per Windows e macOS}
\subsection{Premessa fondamentale: architetture e compatibilità}
\label{par:paragrafo_1_1}
Prima di procedere, è essenziale capire che questi simulatori non sono normali applicazioni installabili con un semplice clic. Entrambi sono nati in ambito accademico per Linux, ma hanno esigenze molto diverse legate alla loro "età".

\vspace{8pt}
\noindent
Questi due simulatori architetturali (Gem5 e MarssX$86$) nascono e vengono sviluppati nativamente per sistemi Unix-like.
\begin{itemize}[leftmargin=1em]
    \item \textbf{macOS} è un sistema certificato Unix. "Parla la stessa lingua" di Linux, quindi può eseguire molti di questi programmi nativamente (direttamente dal terminale), con il solo aiuto di alcune librerie esterne.
    \item \textbf{Windows} ha un'architettura completamente diversa, per cui non può eseguire nativamente questi programmi. Per poterli eseguire è quindi necessario utilizzare delle soluzioni di \textbf{virtualizzazione o sottosistemi} per creare l'ambiente Unix necessario.
\end{itemize}

\vspace{8pt}
\noindent
Bisogna anche considerare che, anche avendo un sistema Linux (o Unix), c'è il problema delle librerie software necessarie per compilare il codice (il "Time Gap").
\begin{itemize}[leftmargin=1em]
    \item \textbf{Gem5} è un software \textbf{moderno e adattivo}, che viene continuamente sviluppato e aggiornato.\\
    Funziona senza problemi sui sistemi operativi moderni: su macOS lo si compila direttamente mentre su Windows si usa WSL con un'installazione Linux recente (Ubuntu $20.04$/$22.04$).
    \item \textbf{MarssX86} è un progetto "legacy" (molto vecchio, fermo ad $2012$ circa). Richiede compilatori (GCC vecchi) e librerie che sono state rimosse dai sistemi operativi moderni da anni.\\
    Nè macOS moderno ne WSL possono eseguirlo facilmente, dunque è necessario creare una \textbf{Macchina virtuale} (con VirtualBox) che simuli un computer del $2014$ con installato \textbf{Ubuntu $14.04$}.
\end{itemize}

\subsection{Installazione e setup del simulatore Gem5}
Per quanto riguarda l'installazione del simulatore Gem5, la soluzione varia leggermente a seconda del sistema operativo utilizzato.
\subsubsection{Installazione e setup di Gem5 su Windows}
\label{par:ch_1.2.1}
Per installare il simulatore su Windows la soluzione consigliata è \textbf{WSL} (Windows Subsystem for Linux). Questo sottosistema permette di avere un terminale Ubuntu vero e proprio integrato in Windows. Dunque, l'installazione si compone di diversi passaggi:
\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: attivazione di WSL}
    \begin{enumerate}[leftmargin=1.3em]
        \item Aprire la \textbf{PowerShell} come amministratore;
        \item Digitare \cmd{\texttt{wsl ---install}}, premere invio e attendere il compleatmento del download;
        \item Al termine, seguire le istruzioni a schermo per creare \textit{username} e \textit{password} Ubuntu.
    \end{enumerate}
    
    \vspace{8pt}
    \noindent
    Una volta fatto ciò, la situazione iniziale nel terminale dovrebbe essere quella mostrata in figura \ref{fig:ch1_fig1}, ed eseguendo il comando \texttt{pwd} sarà possibile vedere il proprio posizionamento all'interno del sottosistema WSL.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.75\textwidth]{chapter1_figures/img1.png}
        \vspace{-5pt}
        \caption{Schermata iniziale del sottosistema WSL}
        \label{fig:ch1_fig1}
    \end{figure}

    \item \textbf{\textit{Passo 2}: installazione delle dipendenze}\\
    Nel terminale di Ubuntu appena aperto incollare questi comandi uno alla volta:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Aggiorna i pacchetti
sudo apt update && sudo apt upgrade -y
    \end{lstlisting}
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Installa compilatori, Python e librerie necessarie a Gem5
sudo apt install build-essential git m4 scons zlib1g zlib1g-dev libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev python3-dev python-is-python3 libboost-all-dev pkg-config libpng-dev libhdf5-dev libcapstone-dev -y
    \end{lstlisting}
    \textbf{\textit{Note}}: facendo copia-incolla dei comandi potrebbero verificarsi dei problemi dovuti ai \textit{"-"} letti dal terminale di Ubuntu come caratteri speciali, in tal caso è consigliato riscriverli a mano.

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: scaricare e compilare Gem5}\\
    Prima di \textbf{scaricare} Gem5 è consigliato creare una cartella adatta a poterlo contenere.\\
    Quest'operazione viene svolta principalmente perché in futuro dovremo scaricare anche il simulatore architetturale \textbf{MarssX86}: così facendo avremo entrambi i simulatori in una cartella apposita.\\
    Senza spostarsi dalla posizione iniziale \texttt{/home/utente} si va a creare la cartella:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
mkdir dev_local // Crea la cartella dev_local
cd dev_local // Ci si sposta dentro dev_local per scaricare gem5
    \end{lstlisting}
    Una volta posizionati in \texttt{/home/utente/dev\_local} è possibile utilizzare il comando \texttt{git clone} per scaricare il simulatore gem5 dal repository ufficiale 
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
//Clonare il repository del progetto nel proprio workspace
git clone (*@\url{https://github.com/gem5/gem5.git}@*) 
    \end{lstlisting}
    Quando la clonazione sarà completata, all'interno di \texttt{dev\_local} sarà presente un'altra cartella nominata "gem5" al cui interno saranno presenti tutti i file necessari per la compilazione del simulatore.

    \vspace{8pt}
    \noindent
    Prima di far partire la compilazione è necessario fare alcune \textbf{premesse importanti}.\\
    Utilizzare un calcolatore con $16$GB o meno di memoria RAM non basterà: Gem5 è enorme e usa template C++ complessi, ogni core che compila può occupare anche 2-3 GB di RAM.
    Inoltre, considerando che Windows utilizza parte di questa RAM, la situazione si complica ulteriormente.\\
    Una possibile soluzione a questo problema, nel caso in cui non si disponesse di un calcolatore con la quantità di RAM necessaria, è quella di "truccare" WSL per dargli più memoria usando il disco fisso come se fosse RAM (operazione di Swap della memoria):
    \begin{enumerate}[leftmargin=1.3em]
        \item Aprire il blocco note di windows;
        \item Incollare esattamente queste righe:
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
[wsl2]
memory=10GB
swap=16GB
        \end{lstlisting}
        In questo modo stiamo dando a WSL massimo $10$GB di RAM vera, ma aggiungiamo $16$GB di "memoria lenta" su disco per evitare che la compilazione vada in crash.
        \item Salvare il file con nome \texttt{.wslconfig} (assicurandosi che non ci sia .txt alla fine!) nella propria cartella utente principale: \texttt{C:\textbackslash Utenti\textbackslash NomeUtente\textbackslash .wslconfig}
        \item Aprire la PowerShell (sempre in modalità amministratore) e spegnere WSL per applicare la modifica con il comando \cmd{\texttt{wsl ---shutdown}}
    \end{enumerate}

    \vspace{8pt}
    \noindent
    Una volta fatte queste modifiche, è finalmente possibile {far partire la compilazione}: riaprendo il terminale Ubuntu e posizionandosi in \texttt{/home/NomeUtente/dev\_local/gem5} deve essere scritto il seguente comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
scons build/ARM/gem5.opt -j 1
    \end{lstlisting}
    Tramite di esso la compilazione viene fatta partire utilizzando un solo core della cpu. Nonostante l'utilizzo dello "Swap" con la memoria del disco, la compilazione può essere talmente pesante che utilizzando più di un core per la compilazione si rischierebbe di saturare la RAM mandando in crash la compilazione.
    È \textbf{assolutamente "normale"} che i tempi di compilazione varino da 1h a 2h in base alla cpu che si ha a disposizione.

    \vspace{8pt}
    \noindent
    \textbf{\textit{Note}}: non appena la compilazione del simulatore ARM termina, per incominciare la compilazione del simulatore RISC-V basterà reinviare il comando \texttt{scons} quì sopra, sostituendo \texttt{ARM} con \texttt{RISCV}.

    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 4}: test di funzionamento}\\
    Per testare che il simulatore sia stato installato correttamente è possibile lanciare un comando di prova già incluso al suo interno.\\
    Sempre posizionati in \texttt{/home/NomeUtente/dev\_local/gem5}, lanciare questo comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
./build/ARM/gem5.opt configs/deprecated/example/se.py --cmd=tests/test-progs/hello/bin/arm/linux/hello    
    \end{lstlisting}
    \begin{figure}[H]
        \centering
        \vspace{-10pt}
        \includegraphics[width=\textwidth]{chapter1_figures/img2.png}
        \vspace{-20pt}
        \caption{test di simulazione per Gem5}
        \label{fig:ch1_fig2}
    \end{figure}
    L'esecuzione di questo comando comporterà la creazione, all'interno della cartella "m5out" situata all'interno della cartella "gem5", di \textbf{due file fondamentali}:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{"stats.txt"}}: Contiene tutte le statistiche (cicli, cache miss, istruzioni eseguite, ecc.). È il file di testo enorme che si dovrà analizzare dopo l'esecuzione vera e propria del workload;
        \item \textbf{\textit{"config.ini"}}: Contiene la descrizione dettagliata dell'hardware appena simulato (utile per verificare se è stata davvero usata la CPU che si voleva).
    \end{itemize}
\end{itemize}

\subsubsection{Installazione e setup di Gem5 su macOS}
Sebbene sia teoricamente possibile compilare nativamente su macOS, la gestione delle dipendenze (in particolare Python e Protobuf) risulta spesso instabile a causa degli aggiornamenti di sistema Apple.

\vspace{8pt}
\noindent
Per garantire la \textbf{massima riproducibilità} e stabilità, la soluzione raccomandata per macOS è l'utilizzo di un container \textbf{Docker} basato su Ubuntu $22.04$. Come per WSL, questo approccio permette di avere un ambiente di sviluppo basato su Linux nativo.

\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: preparazione del container}
    \begin{enumerate}[leftmargin=1.3em]
        \item Scaricare e installare Docker desktop dal sito ufficiale \url{https://www.docker.com/};
        \item È consigliato aprire il terminale posizionandosi nella cartella del proprio apple account come mostrato in figura \ref{fig:ch1_fig3}; 
        \begin{figure}[H]
            \centering
            \vspace{-10pt}
            \includegraphics[width=0.8\textwidth]{chapter1_figures/img3.png}
            \vspace{-5pt}
            \caption{posizionamento iniziale per l'installazione di docker}
            \label{fig:ch1_fig3}
        \end{figure}
        \vspace{-12pt}
        \item Creare il proprio workspace che conterrà il simulatore Gem5 e in futuro MarssX86.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
mkdir dev_local
cd dev_local
        \end{lstlisting}
    \end{enumerate}

    \vspace{8pt}
    \noindent
    \item \textbf{\textit{Passo 2}: installazione delle dipendenze}
    \begin{enumerate}[leftmargin=1.3em]
        \item All'interno di \texttt{/Users/NomeUtente/dev\_local}, installare tutte le dipendenze necessarie per la creazione del container di Ubuntu $22.04$:
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker pull ghcr.io/gem5/ubuntu-24.04_all-dependencies:v25-1
        \end{lstlisting}
        \item Una volta che il workspace è stato creato è possibile far partire il container di Ubuntu (sempre stando posizionati in \texttt{/Users/NomeUtente/dev\_local}):
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
docker run --volume /Users/NomeUtente/dev_local/gem5:/gem5 --rm -it ghcr.io/gem5/ubuntu-24.04_all-dependencies:v24-0        
        \end{lstlisting}
        Il completamento di questo comando dovrebbe aprire una riga di comando di questo tipo, ad indicare che siamo all'interno del container Ubuntu.
        \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
root@1ab1ef08f2f:/#    
        \end{lstlisting}
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: scaricare e compilare Gem5}\\
    All'interno del container Ubuntu appena creato, è possibile \textbf{scaricare} il repository ufficiale tramite il comando \texttt{git clone}:
    \begin{lstlisting}[style=mystyle, language=C++, escapeinside={(*@}{@*)}]
root@1ab1ef08f2f:/#  git clone (*@\url{https://github.com/gem5/gem5.git}@*) 
    \end{lstlisting}
    Verrà creata una cartella "gem5" al cui interno saranno al cui interno saranno presenti tutti i file necessari per la compilazione del simulatore.

    \vspace{8pt}
    Come specificato al \textbf{\textit{"Passo 3"}} del capitolo \ref{par:ch_1.2.1} la compilazione richiede una grande quantità di RAM per cui è richiesto un calcolatore con $16$ o più GB di memoria RAM (solo per la compilazione di Gem5!). Dopo alcuni test da noi effettuati è risultato che la compilazione su un calcolatore con $8$GB di RAM potrebbe impiegare anche mezza giornata!\\
    Proprio per questo motivo, anche disponendo di $16$GB di memoria RAM è necessario andare nella GUI di Docker \texttt{impostazioni} $\rightarrow$ \texttt{resources} $\rightarrow$ \texttt{advanced}, e da quì cambiare le seguenti impostazioni:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{Memory limit}}: impostiamo la capacità massima di memoria RAM che Docker può utilizzare. È consigliato impostarlo quasi al massimo, (ad esempio, con $16$ GB di RAM a disposizione impostarlo a $14/15$) per permettere al sistema operativo (macOS) di "sopravvivere"
        \item \textbf{\textit{Swap}}: Invece, tramite questa impostazione, indichiamo quanto spazio di "memoria lenta" prendere dal disco nel caso in cui la RAM vada in saturazione a causa della pesantezza di compilazione.
    \end{itemize}

    \vspace{8pt}
    Una volta che il repository è stato clonato ci si sposta all'interno della cartella "gem5" per far partire la \textbf{compilazione del simulatore}, utilizzando $1$ o al massimo $2$ core per evitare che la compilazione vada in crash a causa della saturazione della RAM a dispozione.
    \begin{lstlisting}[style=mystyle, language=C, escapeinside={(*@}{@*)}]
// Mi sposto all'interno della cartella gem5
root@1ab1ef08f2f:/#  cd gem5 

// Compilazione ARM
root@1ab1ef08f2f:/gem5# scons build/ARM/gem5.opt -j1 
    \end{lstlisting}
    Come per Windows, anche la compilazione su macOS può impiegare da $1$h a $2$h, ed è \textbf{"normale"} vista la mole di file da scaricare.\\
    \textbf{\textit{Note}}: non appena la compilazione del simulatore ARM termina, per incominciare la compilazione del simulatore RISC-V basterà reinviare il comando \texttt{scons} quì sopra, sostituendo \texttt{ARM} con \texttt{RISCV}.

    \vspace{8pt}
    \textbf{\textit{Passo 4}: test di funzionamento}\\
    Per testare che il simulatore sia stato installato correttamente è possibile lanciare un comando di prova già incluso al suo interno.\\
    Sempre posizionati in \texttt{root@1ab1ef08f2f:/gem5\#}, lanciare questo comando:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
./build/ARM/gem5.opt configs/deprecated/example/se.py --cmd=tests/test-progs/hello/bin/arm/linux/hello    
    \end{lstlisting}
    L'esecuzione di questo comando comporterà la creazione, all'interno della cartella "m5out" situata all'interno della cartella "gem5", di \textbf{due file fondamentali}:
    \begin{itemize}[leftmargin=1em, label=\raisebox{0.4ex}{\phantom{1}\rule{0.6ex}{0.6ex}}]
        \item \textbf{\textit{"stats.txt"}}: Contiene tutte le statistiche (cicli, cache miss, istruzioni eseguite, ecc.). È il file di testo enorme che si dovrà analizzare dopo l'esecuzione vera e propria del workload;
        \item \textbf{\textit{"config.ini"}}: Contiene la descrizione dettagliata dell'hardware appena simulato (utile per verificare se è stata davvero usata la CPU che si voleva).
    \end{itemize}
\end{itemize}


\subsection{Installazione e setup del simulatore MarssX86}
Come detto precedentemente al capitolo \ref{ch1:par:paragrafo_1_1}, MarssX$86$ è troppo vecchio per funzionare su WSL moderlo o su macOS. Esistono due strade che risolvono il problema, le quali funzionano sia per Windows che per macOS:

\subsubsection{Docker}
L'utilizzo di Docker è da prendere in considerazione nel caso in cui si voglia una maggiore rapidità, si è comodi con la riga di comando e si vuole tenere il pc pulito. Infatti, permette di scaricare un immagine di Ubuntu $14.04$ e lavorarci dentro da terminale senza installare un intero sistema operativo.
\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: Installare Docker}
    \begin{enumerate}[leftmargin=1.3em]
        \item Windows/macOS: scaricare e installare Docker desktop dal sito ufficiale \url{https://www.docker.com/};
        \item Avviarlo e assicurarsi che sia attivo (controllare l'icona della balena nella barra delle applicazioni).
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 2}: Creare l'ambiente (il Dockerfile)}\\
    Creare una cartella sul computer chiamata \textbf{\textit{"marss\_project"}} e al suo interno creare un file di testo chiamato  \textbf{\textit{"Dockerfile"}} in cui andrà incollato al suo interno il seguente contenuto:
    \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
// Si usa una versione vecchia di Ubuntu compatibile con MarssX86
FROM ubuntu:14.04

// Aggiornare i repository per trovare i vecchi pacchetti
RUN apt-get update && \
    apt-get install -y build-essential git scons zlib1g-dev python g++ vim

// Impostare la cartella di lavoro
WORKDIR /root/marss

// Comando di default quando si entra nel container
CMD ["/bin/bash"]
    \end{lstlisting}

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: costruire e avviare}\\
    Aprire il terminale (o PowerShell) nella cartella dove è stato inserito il Dokerfile.
    \begin{enumerate}[leftmargin=1.3em]
        \item \textbf{Costruzione dell'immagine } tramite il comando:
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
docker build -t marss_env .
        \end{lstlisting}

        \item \textbf{Ingresso nel contenitore} tramite il comando:
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
docker run -it --name marss_container marss_env
        \end{lstlisting}
        Una volta dentro, il terminale "penserà" di essere nel $2014$ garantendo la possibilità di scaricare e compilare MarssX$86$ li dentro
    \end{enumerate}
\end{itemize}

\subsubsection{VirtualBox}
Invece, la VirtualBox è consigliata se si preferisce avere un'iterfaccia grafica, quindi vedere le finestre e usare un editor di testo grafico dentro la macchina virtuale, perché permette di avere un'esperienza più simile all'utilizzo di un computer fisico.
\begin{itemize}[leftmargin=1em]
    \item \textbf{\textit{Passo 1}: scaricare e installare il software}
    \begin{enumerate}[leftmargin=1.3em]
        \item Scaricare e installare \textbf{VirtualBox} al seguente indirizzo \url{https://www.virtualbox.org/};
        \item Scaricare la ISO di Ubuntu $14.04$ LTS (Trusty Tahr) al seguente indirizzo \url{https://releases.ubuntu.com/14.04/}
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 2}: creazione della macchina virtuale}
    \begin{enumerate}[leftmargin=1.3em]
        \item Aprire la virtualbox e andare su "nuova";
        \item Nome: \textit{"MarssVM"}, Tipo: \textit{"Linux"}, Versione: \textit{Ubuntu (64-bit)};
        \item È necessario assegnare almeno 4GB di RAM e $2-4$ processori, fondamentali per la velocità di compilazione.
        \item Creare un disco fisico di almeno 30GB;
        \item Avviare la macchina, selezionare la ISO scaricata precedentemente e installare Ubuntu come se fosse un pc vero.
    \end{enumerate}

    \vspace{8pt}
    \item \textbf{\textit{Passo 3}: setup interno}\\
    Una volta che Ubuntu è stato installato nella virtual machine, aprire il terminale interno e lanciare i seguenti comandi, uno alla volta:
    \begin{enumerate}[leftmargin=1em]
        \item Questo comando serve per scaricare la lista aggiornata di tutto il software disponibile.
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
sudo apt-get update
        \end{lstlisting}
        \item Serve per installare i \textbf{compilatori di C++} (build-essential e g++) che traducono il codice in linguaggio macchina, il \textbf{gestore dei file} (scons) che lancia in automatico tutt i file necesssari, \textbf{git} per scaricare il codice da internet e \textbf{python} perché molti script di configurazione di MarssX86 sono scritti in quel linguaggio.
        \begin{lstlisting}[style=mystyle, language=C, , escapeinside={(*@}{@*)}]
sudo apt-get install build-essential git scons zlib1g-dev python g++
        \end{lstlisting}
    \end{enumerate}
\end{itemize}
\end{document}